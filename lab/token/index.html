<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<script
  data-goatcounter="https://todepond.goatcounter.com/count"
  async
  src="//gc.zgo.at/count.js"></script>
<title>Tadi lab</title>
<link rel="shortcut icon" href="/favicon.png" />
<meta property="og:image" content="https://todepond.com/lab/og.png" />
<meta property="og:title" content="Tadi lab" />
<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:title" content="Tadi lab" />
<meta name="twitter:description" content="" />
<meta name="twitter:image" content="https://todepond.com/lab/og.png" />

<link rel="stylesheet" href="/style.css" />

<style>
  * {
    overscroll-behavior: none;
    /* box-sizing: border-box; */
  }

  body {
    /* font-family: "Inter", sans-serif; */
    margin: 0;
    padding: 0;
    /* background-color: #f5f5f5; */
    width: 100%;
    max-width: 100%;
    height: 100%;
  }

  main {
    display: flex;
    width: 100%;
    height: 100%;
    overflow: hidden;
  }

  #input {
    width: 100%;
    border: none;
    resize: none;
    min-width: 50%;
    outline: none;
    tab-size: 4;
    font-size: 1.1rem;
    padding: 2.5px 5px;
  }

  #preview {
    padding: 5px 5px;
    flex-shrink: 0;
    min-width: 350px;
    max-width: 50%;
    overflow-y: auto;
    white-space: pre;
    font-family: monospace;
    font-size: 1.1rem;
  }

  table {
    font-size: 1.1rem;
    border: 1px solid var(--best-colour);
    border-collapse: collapse;
    width: 100%;
    overflow: scroll;
    white-space: nowrap;
  }

  td {
    padding: 0.2rem 0.4rem;
    border: 1px solid var(--shade-5);
  }

  td:first-child {
    color: var(--shade-6);
    /* flex-shrink: 0; */
  }

  tr:first-child td {
    /* font-weight: bold; */
    /* color: white; */
  }

  @media (max-width: 760px) {
    main {
      flex-direction: column;
    }

    #input {
      width: 100%;
      height: 50%;
    }

    #preview {
      width: 100%;
      height: 50%;
    }
  }
</style>

<main>
  <textarea id="input" wrap="off" spellcheck="false"></textarea>
  <div id="preview"></div>
</main>

<script>
  const input = document.getElementById("input");
  const preview = document.getElementById("preview");

  function handleInput() {
    const tokens = tokenise(input.value);
    // console.log(tokens);
    preview.innerHTML =
      "<table>" +
      tokens
        .map((v) => {
          const value = v.value?.replaceAll("\n", "\\n") ?? v.type;
          return {
            raw: v,
            colour: getTokenColour(v),
            formatted: value,
          };
        })
        .map(
          (v) =>
            `<tr><td>${v.raw.type}</td><td><span style="color: ${v.colour}">${v.formatted}</span></td></tr>`
        )
        .join("\n") +
      "</table>";
  }

  function getTokenColour(token) {
    switch (token.type) {
      case "line-end":
        return "var(--best-colour-faded)";
      case "quote":
        return "var(--coral)";
      case "list-start":
      case "list-end":
        return "var(--calm-yellow)";
      case "error":
        return "var(--red)";
      case "symbol": {
        switch (token.value) {
          case "rewrite":
            return "#4699ff";
        }
        return "";
      }
    }
    return "";
  }

  input.addEventListener("keydown", (e) => {
    if (e.key === "Tab") {
      e.preventDefault();
      document.execCommand?.("insertText", false, "\t");
    }
  });

  input.addEventListener("input", handleInput);
  input.value = `hello world
rewrite \`name\` \`luke\`
hello name
rewrite (\`full\` \`name\`) \`luke wilson\`
rewrite handle "todepond"
`;

  function tokenise(input) {
    let tokens = [{ type: "empty" }];

    let i = 0;
    while (i < input.length) {
      const character = input[i];
      const token = tokens[tokens.length - 1];

      if (character.match(/[ \t]/)) {
        if (token.type === "symbol") {
          tokens.push({ type: "empty" });
          i++;
          continue;
        }
        if (token.type === "empty") {
          i++;
          continue;
        }
      }

      if (character === "\n") {
        if (token.type === "quote") {
          tokens.pop();
          tokens.push({ type: "error", value: `unfinished ${token.type}` });
          tokens.push({ type: "line-end", value: "\n" });
          tokens.push({ type: "empty" });
          i++;
          continue;
        }
        if (token.type === "empty") {
          tokens.pop();
        }
        const lastToken = tokens[tokens.length - 1];
        if (lastToken?.type === "line-end") {
          tokens.pop();
        }
        tokens.push({ type: "line-end", value: "\n" });
        tokens.push({ type: "empty" });
        i++;
        continue;
      }

      if (character === "`") {
        if (token.type === "quote") {
          token.value += character;
          tokens.push({ type: "empty" });
          i++;
          continue;
        }

        if (token.type === "empty") {
          tokens.pop();
        }

        tokens.push({ type: "quote", value: "`" });
        i++;
        continue;
      }

      if (character === "(") {
        if (token.type === "empty") {
          tokens.pop();
        }
        tokens.push({ type: "list-start", value: "(" });
        tokens.push({ type: "empty" });
        i++;
        continue;
      }

      if (character === ")") {
        if (token.type === "empty") {
          tokens.pop();
        }
        tokens.push({ type: "list-end", value: ")" });
        tokens.push({ type: "empty" });
        i++;
        continue;
      }

      if (token.type === "empty") {
        token.type = "symbol";
        token.value = "";
      }

      token.value += character;
      i++;
    }

    if (tokens[0]?.type === "line-end") {
      tokens.shift();
    }

    if (tokens[tokens.length - 1]?.type === "quote") {
      const unfinishedToken = tokens.pop();
      tokens.push({
        type: "error",
        value: `unfinished ${unfinishedToken.type}`,
      });
    }

    if (tokens[tokens.length - 1]?.type === "empty") {
      tokens.pop();
    }

    if (tokens[tokens.length - 1]?.type === "line-end") {
      tokens.pop();
    }

    tokens.push({ type: "line-end", value: "EOF" });

    return tokens;
  }

  handleInput();
</script>
